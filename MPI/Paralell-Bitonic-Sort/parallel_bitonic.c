/* File:
 *   parallel_bitonic.c
 * Author:     Lyndon Ong Yiu
 * Purpose:
 *   Implement serial parallel sort of a list that is either user
 *   input or generated by the program using a random number
 *   generator.
 *
 * Compile:  
 *   mpicc -g -Wall -o pbit parallel_bitonic.c
 *
 * Run:
 *   ./pbit <n> <'i'|'g'>
 *      n = number of elements in the list (a power of 2)
 *      'i':  user will enter list (no quotes)
 *      'g':  program should generate list (no quotes)
 *
 * Input:
 *    If command line option 'i' is used, an n-element list of
 *    ints
 *
 * Output:
 *    The unsorted list and the sorted list.
 *
 * Notes:
 *    1.  If the list is randomly generated, the keys are in the range 
 *       1 -- KEY_MAX.
 *    2.  The size of the list, n, should be a power of 2:  the program
 *       doesn't check that this is the case.
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <mpi.h>
#include <string.h>

/* Successive subsequences will switch between
 * increasing and decreasing bitonic splits.
 */
#define INCR 0
#define DECR 1
#define KEY_MAX 100

void Get_args(int argc, char* argv[], int* n_p, char* ig_p);
void Read_list(char title[], int A[], int n);
void Gen_list(int A[], int n);
void Print_list(char* title, int A[], int n);
int cmpfunc (const void * a, const void * b);
void bit_Butterfly(int loc_n, int p, int my_rank, int loc_a[], MPI_Comm comm);
void mergeSplitLow(int loc_a[], int part_a[], int loc_n);
void mergeSplitHigh(int loc_a[], int part_a[], int loc_n);
void chooseSplit(int loc_a[], int part_a[], int loc_n, int partner, MPI_Comm comm, int my_rank, int order);



/*-------------------------------------------------------------------*/
int main(int argc, char* argv[]) {
   int* A;
   int* loc_a;
   char   ig;
   int loc_n, p, my_rank, n;
   MPI_Comm comm;
   MPI_Init(&argc, &argv);
   comm = MPI_COMM_WORLD;
   MPI_Comm_size(comm, &p);
   MPI_Comm_rank(comm, &my_rank);
   if (my_rank ==0){
      Get_args(argc, argv, &n, &ig);
      A = malloc(n*sizeof(int));
      if (ig == 'i')
         Read_list("Enter the list", A, n);
      else
         Gen_list(A, n);
      Print_list("The unsorted list is", A, n);
   }
   MPI_Bcast(&n, 1, MPI_INT, 0, comm);
   loc_n = n / p;
   loc_a = malloc(loc_n*sizeof(int));
   MPI_Scatter(A, loc_n, MPI_INT, loc_a, loc_n, MPI_INT, 0, comm);
   # ifdef DEBUG
         printf("Proc %d", my_rank);
         Print_list("before butterfly loc_a = ", loc_a, loc_n);
   # endif
   qsort(loc_a, loc_n, sizeof(int), cmpfunc);
   bit_Butterfly(loc_n, p, my_rank, loc_a, comm);
   MPI_Gather(loc_a, loc_n, MPI_INT, A, loc_n, MPI_INT, 0, comm);
   if (my_rank == 0){
      Print_list("The sorted list is", A, n);
   }
   if (my_rank == 0) free(A);
   free(loc_a);
   MPI_Finalize();
   return 0;
}  /* main */


/*---------------------------------------------------------------------
 * Function:   cmpfunc
 * Purpose:    Compare function used for qsort
 * In args:    a = integer as a void*
 *          b = integer as a void*
 * Out args:   the difference between a and b
 */
int cmpfunc (const void * a, const void * b){
   return ( *(int*)a - *(int*)b);
}

/*---------------------------------------------------------------------
 * Function:  bit_butterfly
 * Purpose:   Utilizes three unsigned binary integers to assign partners
 *         for a bitonic butterfly sort. Actual sorting is handled in 
 *         the merge/split functions, this function simply assigns 
 *         partners to do merge/splits with in a butterfly format
 * In args:   loc_a = local array
 *         loc_n = size of both arrays
 *         comm = communicator
 *         my_rank = local rank
 */
void bit_Butterfly(int loc_n, int p, int my_rank, int loc_a[], MPI_Comm comm){
   unsigned bit_a = 2; //size of increasing/decreasing blocks
   unsigned bit_b = 1;
   unsigned bit_c = 1;
   int partner;
   int order;
   int* part_a = malloc(loc_n*sizeof(int));
   while (bit_a <= p){
      if ((my_rank & bit_a) == 0){
        order = INCR;
      }
      else{
        order = DECR;
      }
      partner = my_rank ^ bit_b;
      # ifdef DEBUG
         printf("Proc %d | outer while | partner = %d | order = %d | butterfly scale = %d", 
            my_rank, partner, order, bit_a);
         Print_list("loc_a = ", loc_a, loc_n);
      # endif
      chooseSplit(loc_a, part_a, loc_n, partner, comm, my_rank, order);
      while (bit_c != 1){
        bit_c >>= 1;
        partner = my_rank ^ bit_c;
        # ifdef DEBUG
            printf("Proc %d | inner while | partner = %d | order = %d | butterfly scale = %d",
             my_rank, partner, order, bit_a);
            Print_list("loc_a = ", loc_a, loc_n);
      # endif
        chooseSplit(loc_a, part_a, loc_n, partner, comm, my_rank, order);
      }
      bit_a <<= 1;
      bit_b <<= 1;
      bit_c = bit_b;
   }
   free(part_a);
}

/*---------------------------------------------------------------------
 * Function:  chooseSplit
 * Purpose:   Based on partner rank, and increasing/decreasing order, uses partner rank and
 *         order, first send/recieves arrays between partners, and then calls the appropriate 
 *         merge/split function on each process
 * In args:   loc_a = local array
 *         part_a = partner array
 *         loc_n = size of both arrays
 *         partner = partner rank
 *         comm = communicator
 *         my_rank = local rank
 *         order = increasing/decreasing order for given process
 */
void chooseSplit(int loc_a[], int part_a[], int loc_n, int partner, MPI_Comm comm, int my_rank, int order){
   MPI_Sendrecv(loc_a, loc_n, MPI_INT, partner, 0, part_a, 
         loc_n, MPI_INT, partner, 0, comm, MPI_STATUS_IGNORE);
      if (order == INCR){
         if (my_rank < partner){
         mergeSplitLow(loc_a, part_a, loc_n);
         }
         else{
         mergeSplitHigh(loc_a, part_a, loc_n);
         }
   }
   else if (order == DECR){
         if (my_rank > partner){
         mergeSplitLow(loc_a, part_a, loc_n);
         }
         else{
         mergeSplitHigh(loc_a, part_a, loc_n);
         }
    }
}

/*---------------------------------------------------------------------
 * Function:  mergeSplitLow
 * Purpose:   Merges two arrays of size loc_n, and returns the lower 
 *         half of the array in loc_a
 * In args:   loc_a = local array
 *         part_a = partner array
 *         loc_n = size of both arrays
 */
void mergeSplitLow(int loc_a[], int part_a[], int loc_n){
   int i = 0;
   int j = 0;
   int x;
   int* temp_a = malloc(loc_n*sizeof(int));
   for (x = 0; x < loc_n; x++){
      if (loc_a[i] < part_a[j]){
         temp_a[x] = loc_a[i];
         i++;
      }
      else{
         temp_a[x] = part_a[j];
         j++;
      }
   }
   for (x = 0; x < loc_n; x++){
      loc_a[x] = temp_a[x];
   }
   free(temp_a);
}

/*---------------------------------------------------------------------
 * Function:  mergeSplitHigh
 * Purpose:   Merges two arrays of size loc_n, and returns the larger 
 *         half of the array in loc_a
 * In args:   loc_a = local array
 *         part_a = partner array
 *         loc_n = size of both arrays
 */
void mergeSplitHigh(int loc_a[], int part_a[], int loc_n){
   int i = loc_n - 1;
   int j = loc_n - 1;
   int x;
   int* temp_a = malloc(loc_n*sizeof(int));
   for (x = (loc_n - 1); x >= 0; x--){
      if (loc_a[i] > part_a[j]){
         temp_a[x] = loc_a[i];
         i--;
      }
      else{
         temp_a[x] = part_a[j];
         j--;
      }

   }
   for (x = 0; x < loc_n; x++){
      loc_a[x] = temp_a[x];
   }
   free(temp_a);
}

/*---------------------------------------------------------------------
 * Function:  Get_args
 * Purpose:   Get the command line arguments
 * In args:   argc, argv
 * Out args:  n_p:  pointer to list size
 *         ig_p:  pointer to 'i' if user will input list,
 *            otherwise pointer to '
 */
void Get_args(int argc, char* argv[], int* n_p, char* ig_p) {
   if (argc != 3) {
      fprintf(stderr, "usage: %s <n> <'i'|'g'>\n", argv[0]);
      fprintf(stderr, "   n = number of elements in the list (a power of 2)\n");
      fprintf(stderr, "   'i':  user will enter list (no quotes)\n");
      fprintf(stderr, "   'g':  program should generate list (no quotes)\n");
      exit(0);
   }
   *n_p = strtol(argv[1], NULL, 10);
   *ig_p = argv[2][0];
}  /* Get_args */

/*---------------------------------------------------------------------
 * Function:  Read_list
 * Purpose:   Read in a list of ints
 * In arg:    n
 * Out arg:   A
 */
void Read_list(char title[], int A[], int n) {
   int i;

   printf("%s\n", title);
   for (i = 0; i < n; i++)
      scanf("%d", &A[i]);

}  /* Read_list */


/*---------------------------------------------------------------------
 * Function:   Gen_list
 * Purpose:    Use a random number generator to generate an n-element
 *             list
 * In arg:     n
 * Out arg:    A
 * Note:       Elements of the list are in the range 1 -- KEY_MAX
 */
void Gen_list(int A[], int n) {
   int i;

   srandom(1);
   for (i = 0; i < n; i++)
      A[i] = 1 + random() % KEY_MAX; 
}  /* Gen_list */ 




/*---------------------------------------------------------------------
 * Function:   Print_list
 * Purpose:    Print the elements of A
 * In args:    all
 */
void Print_list(char* title, int A[], int n) {
   int i;

   printf("%s\n", title);
   for (i = 0; i < n; i++)
      printf("%d ", A[i]);
   printf("\n");
}  /* Print_list */

